#!/bin/sh
#
#   "SystemImager"
#
#   $Id$
#    vi:set filetype=sh:
#
#   Copyright (C) 1999-2010 Brian Elliott Finley
#
#   28.07.2005 Erich Focht : SCSI device detection and generation of
#                            /sysroot/etc/systemconfig/hardware.lst
#
#   David N. Lombard : Disks enumeration and disk editing
#
##VERSION_INFO##
# Using the following command:
##SI_CREATE_AUTOINSTALL_SCRIPT_CMD##

# Pull in variables left behind by the linuxrc script.
# This information is passed from the linuxrc script on the autoinstall media 
# via /tmp/variables.txt.  Apparently the shell we use in BOEL is not 
# intelligent enough to take a "set -a" parameter.
#
. /tmp/variables.txt

# Load functions and other variables
. /lib/autoinstall-lib.sh

get_arch

##NO_LISTING##
if [ -z $NO_LISTING ]; then
    VERBOSE_OPT="v"
else
    VERBOSE_OPT=""
fi

##SET_IMAGENAME##
##SET_OVERRIDES##

# Check to be sure this not run from a working machine
fail_if_run_from_working_machine

################################################################################
#
#   Stop RAID devices before partitioning begins
#
# Q1) Why did they get started in the first place?  
# A1) So we can pull a local.cfg file off a root mounted software RAID system.
#     They may not be started on your system -- they would only be started if
#     you did the stuff in Q3 below.
#
# Q2) Why didn't my local.cfg on my root mounted software RAID work for me 
#     with the standard kernel flavour?
# A2) The standard kernel flavour uses modules for the software RAID drivers --
#     therefore, software RAID is not available at the point in the boot process
#     where BOEL needs to read the local.cfg file.  They are only pulled over 
#     when this script is run, which is, of course, only runnable if it was
#     pulled over the network using the settings that you would have wanted it
#     to get from the local.cfg file, which it couldn't.  Right?
#
# Q3) Whatever.  So how do I make it work with a local.cfg file on my root
#     mounted software RAID?  
# A3) Compile an autoinstall kernel with software RAID, and any other drivers 
#     you might need built in (filesystem, SCSI drivers, etc.).
#
# OL: BUG: FAQ obsolete. Need complete re-testing

if [ -f /proc/mdstat ]; then
  RAID_DEVICES=` cat /proc/mdstat | grep ^md | sed 's/ .*$//g' `

  # Turn dem pesky raid devices off!
  for RAID_DEVICE in ${RAID_DEVICES}
  do
    DEV="/dev/${RAID_DEVICE}"
    loginfo "mdadm --manage ${DEV} --stop"
    mdadm --manage ${DEV} --stop
  done
fi
#
################################################################################
# BEGIN disk enumeration
#
# Note the kludgey way to get /dev/sd* and /dev/*/c*d* to sort properly...
#
# Parse the correct file depending by the kernel release -AR-
kernel=`uname -r | sed "s/^\(2\.[64]\).*/\1/"`
if [ $kernel = "2.4" ]; then
    diskfile=/proc/partitions
else
    diskfile=/proc/diskstats
fi 

##SET_DISKORDER##

[ -z $DISKORDER ] || {
  loginfo "Detecting disks..."
  order=`echo "$DISKORDER" | sed 's/ /,/g' | sed s/,,*/,/g | sed s/^,//`
  DISKS=0
  cdroms=`cat /proc/sys/dev/cdrom/info 2>/dev/null | sed -ne "s/^drive name:[[:space:]]*//p"`
  while : ; do
    [ -z $order ] && break
    type=`expr $order : '\([^,]*\),' \| $order`
    case $type in
    cciss | ida | rd )
      for dev in `cat $diskfile | sed -ne "s/.*\($type\\/c[0-9]d[0-9]\).*/\1/p" | sort -u` ; do
        loginfo " $dev"
        eval DISK$DISKS=/dev/${dev}
        DISKS=`expr $DISKS + 1`
      done
      ;;
    hd | sd | xvd )
      for dev in `cat $diskfile | sed -ne "s/.*\($type[a-z]\+\).*/\1/p" | sort -u` ; do
        skip=0
        for cdrom in $cdroms; do
            if [ "$dev" = "$cdrom" ]; then
                skip=1
                break
            fi
        done
        if [ $skip -eq 0 ]; then
            loginfo " $dev"
            eval DISK$DISKS=/dev/${dev}
            DISKS=`expr $DISKS + 1`
        fi
      done
      ;;
    * )
      loginfo "type='$type'"
      shellout
      ;;
    esac
    order=`expr $order : '[^,]*,\(.*\)'`
  done
  loginfo DISKS=$DISKS
  [ $DISKS -eq 0 ] && {
    beep
    beep
    logwarn ""
    logwarn "NO DISK DEVICE FILES WERE FOUND.  THIS USUALLY MEANS THE KERNEL DID NOT"
    logwarn "RECOGNIZE ANY OF THE ATTACHED DISKS."
    logwarn ""
    logwarn "The kernel boot messages, which preceded this, may indicate why."
    logwarn ""
    logwarn "Reverting to disk configuration specified by image master script."
    DISKORDER=
    logwarn ""
  }
  echo
  beep
}
#
# END disk enumeration
################################################################################

##PARTITION_DISKS##

### BEGIN software-RAID initialization commands -AR- ###
##CREATE_SOFT_RAID_DISKS##
### END software-RAID initialization commands ###

loginfo "Load device mapper driver (for LVM)."
modprobe dm-mod

### BEGIN LVM initialization commands -AR- ###
##INITIALIZE_LVM_PARTITIONS##
### END LVM initialization commands ###

### BEGIN LVM groups creation commands -AR- ###
##CREATE_LVM_GROUPS##
### END LVM groups creation commands ###

### BEGIN LVM volumes creation commands -AR- ###
##CREATE_LVM_VOLUMES##
### END LVM volumes creation commands ###

loginfo "Load additional filesystem drivers."
modprobe ext2
modprobe ext3
modprobe ext4
modprobe fat
modprobe jfs
modprobe reiserfs
modprobe vfat
modprobe xfs

### BEGIN swap and filesystem creation commands ###
##CREATE_FILESYSTEMS##
### END swap and filesystem creation commands ###

# Mount os filesystems to /sysroot (will shellout in case of failure)
mount_os_filesystems_to_sysroot

################################################################################
#
#   Lay the image down on the freshly formatted disk(s)
#
if [ ! -z "$MONITOR_SERVER" ]; then
    start_report_task
fi

if [ ! -z "$FLAMETHROWER_DIRECTORY_PORTBASE" ]; then 

    # Use multicast 
    MODULE_NAME="${IMAGENAME}"
    DIR=/sysroot
    RETRY=7
    FLAMETHROWER_TARPIPE=y
    flamethrower_client
    if [ ! -z $MONITOR_SERVER ]; then
        stop_report_task 101 # 101: status=finalizing...
    fi
elif [ "x$BITTORRENT" = "xy" ]; then
    # Use BitTorrent
    if [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent" ]; then
        bittorrent_tarball="image-${IMAGENAME}.tar.gz"
        compress='z'
    elif [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent" ]; then
        bittorrent_tarball="image-${IMAGENAME}.tar"
        compress=''
    else
        shellout "error: cannot find a valid torrent file for the image ${IMAGENAME}"
    fi
    # Evaluate the staging directory
    if [ -z "$BITTORRENT_STAGING" ]; then
        loginfo bittorrent_autodetect_staging_dir
        BITTORRENT_STAGING=`bittorrent_autodetect_staging_dir ${TORRENTS_DIR}/${bittorrent_tarball}.torrent`
        if [ -z $BITTORRENT_STAGING ]; then
            logerror ""
            logerror "Cannot find a staging directory to save file: $bittorrent_tarball"
            logerror "Try to increase the size of a partition (like /tmp) in your patitioning schema"
            logerror "to fit the image into a staging directory."
            shellout ""
        fi
        loginfo "--> staging in: $BITTORRENT_STAGING"
    fi
    # Download image from peers
    loginfo "Start downloading image using torrent ${bittorrent_tarball}.torrent"
    loginfo "--> INFO: remember to start /etc/init.d/systemimager-server-bittorrent on the image server!"
    bittorrent_get_file ${TORRENTS_DIR}/${bittorrent_tarball}.torrent ${BITTORRENT_STAGING}
    if [ ! -z "$MONITOR_SERVER" ]; then
        stop_report_task 101 # 101: status=finalizing...
    fi
    # Extract image.
    logaction "Extracting image from ${bittorrent_tarball} ..."
    (cd /sysroot/ && tar -x${VERBOSE_OPT}${compress}Spf ${BITTORRENT_STAGING}/${bittorrent_tarball} > /dev/console) || shellout "Failed to extract image from bittorrent tarball."

    # Stop BitTorrent client.
    bittorrent_stop
    rm -f ${BITTORRENT_STAGING}/${bittorrent_tarball}
    unset bittorrent_tarball
else 
    # Use rsync 
    if [ $NO_LISTING ]; then
        logaction "Quietly installing image... "
    fi
    if [ "${TMPFS_STAGING}" = "yes" ]; then 

        # Deposit image into tmpfs
        DIR=/tmp/tmpfs_staging
        loginfo "TMPFS_STAGING=${TMPFS_STAGING} -- Staging in ${DIR}"
        mkdir -p ${DIR}

        logaction "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids \
              ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/ > /dev/console || shellout 

        if [ ! -z $MONITOR_SERVER ]; then
            stop_report_task 101 # 101: status=finalizing...
        fi

        # Move from staging in tmpfs to disk
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${DIR}/ /sysroot/ > /dev/console || shellout
    else
        logaction "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /sysroot/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /sysroot/ > /dev/console || shellout 
        if [ ! -z $MONITOR_SERVER ]; then
            stop_report_task 101 # 101: status=finalizing...
        fi
    fi
fi 

beep

#
################################################################################


# Leave notice of which image is installed on the client
echo $IMAGENAME > /sysroot/etc/systemimager/IMAGE_LAST_SYNCED_TO || shellout

### BEGIN generate new fstab file from autoinstallscript.conf ###
##GENERATE_FSTAB##
### END generate new fstab file from autoinstallscript.conf ###

################################################################################
#
#   Process override directories
#
for OVERRIDE in $OVERRIDES
do
    if [ ! -z $FLAMETHROWER_DIRECTORY_PORTBASE ]; then
        # Use multicast
        MODULE_NAME="override_${OVERRIDE}"
        DIR=/sysroot
        RETRY=7
        FLAMETHROWER_TARPIPE=y
        flamethrower_client
    elif [ "x$BITTORRENT" = "xy" ]; then
        # Use BitTorrent
        if [ -f "${TORRENTS_DIR}/override-${OVERRIDE}.tar.gz.torrent" ]; then
            bittorrent_tarball="override-${OVERRIDE}.tar.gz"
            compress='z'
        elif [ -f "${TORRENTS_DIR}/override-${OVERRIDE}.tar.torrent" ]; then
            bittorrent_tarball="override-${OVERRIDE}.tar"
            compress=''
        else
            bittorrent_tarball=""
            logwarn "Cannot find a valid torrent file for override ${OVERRIDE}"
        fi
        # Evaluate the staging directory
        if [ ! -z $bittorrent_tarball ] && [ -z $BITTORRENT_STAGING ]; then
            loginfo bittorrent_autodetect_staging_dir
            BITTORRENT_STAGING=`bittorrent_autodetect_staging_dir ${TORRENTS_DIR}/${bittorrent_tarball}.torrent`
            if [ -z $BITTORRENT_STAGING ]; then
                logwarn "Cannot find a staging directory to save file: $bittorrent_tarball"
                bittorrent_tarball=""
            fi
            loginfo "--> staging in: $BITTORRENT_STAGING"
        fi
        if [ ! -z $bittorrent_tarball ]; then
            # Start downloading
            loginfo "Start downloading override using torrent ${bittorrent_tarball}.torrent"
            loginfo "--> INFO: remember to start /etc/init.d/systemimager-server-bittorrent on the image server!"
            # Download override from peers
            bittorrent_get_file ${TORRENTS_DIR}/${bittorrent_tarball}.torrent ${BITTORRENT_STAGING}
            # Extract override.
            logaction "Extracting override from ${bittorrent_tarball} ..."
            (cd /sysroot/ && tar -x${VERBOSE_OPT}${compress}Spf ${BITTORRENT_STAGING}/${bittorrent_tarball} > /dev/console) || shellout "Failed to extract override from ${bittorrent_tarball}."
            # Stop BitTorrent client.
            bittorrent_stop
            rm -f ${BITTORRENT_STAGING}/${bittorrent_tarball}
        else
            # Use rsync
            loginfo "trying to download override ${OVERRIDE} with rsync..."
            loginfo "rsync -aIv --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /sysroot/"
            rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /sysroot/ > /dev/console || logwarn "Override directory $OVERRIDE doesn't seem to exist, but that may be OK."
        fi
        unset bittorrent_tarball
    else
        # Use rsync
        loginfo "rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /sysroot/"
        rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /sysroot/ > /dev/console || logwarn "Override directory $OVERRIDE doesn't seem to exist, but that may be OK."
    fi
done

beep

##################################################################
#
# Uncomment the line below to leave your hostname blank.
# Certain distributions use this as an indication to take on the
# hostname provided by a DHCP server.  The default is to have
# SystemConfigurator assign your clients the hostname that
# corresponds to the IP address the use during the install.
# (If you used to use the static_dhcp option, this is your man.)
#
#HOSTNAME=""


################################################################################
#
#XXX use of SystemConfigurator is deprecated
#   Detect scsi hardware and include the device IDs into the hardware.lst
#   file used by systemconfigurator.  Use pci-automod for 2.6 kernels.
#
#   (no longer support 2.4 kernels -BEF-)
#
#[ ! -d /sysroot/etc/systemconfig ] && mkdir -p /sysroot/etc/systemconfig
#if [ -e /tmp/hardware.lst ]; then
#    # use previously generated hardware.lst
#    cat /tmp/hardware.lst >> /sysroot/etc/systemconfig/hardware.lst
#elif [ -d /sys/bus -a -e /lib/modules/`uname -r`/modules.pcimap ]; then
#    # use pci-automod to generate hardware.lst
#    logmsg "Using pci-automod to generate hardware.lst (this may take a long time):"
#    pci-automod --hwlist --class storage --class net --class serial --class bridge > /sysroot/etc/systemconfig/hardware.lst
#    logmsg "done"
#fi
#
################################################################################

################################################################################
#
#XXX use of SystemConfigurator is deprecated
#   System Configurator
#
# Configure the client's hardware, network interface, and boot loader.
#

#XXX Even without SystemConfigurator, is this bit needed for boot loader
#install perhaps?
# Create an /etc/mtab file with appropriate entries
#cat /etc/mtab | grep -v '/dev/ram' | grep -v -E '^\/dev\s+\/sysroot\/dev\s' | sed 's,/sysroot/*,/,g' | sort -u > /sysroot/etc/mtab

## Save original boot-loader configurations before running systemconfigurator
#for file in /sysroot/boot/grub/menu.lst /sysroot/etc/lilo.conf /sysroot/etc/grub.conf; do
#    if [ -e ${file} ]; then
#        if [ ! -e ${file}.pre-systemimager ]; then
#            cp -f ${file} ${file}.pre-systemimager
#        fi
#    fi
#done

##SYSTEMCONFIGURATOR_PRE##

################################################################################
# BEGIN disk edits
#
[ -z $DISKORDER ] || {
  echo "Editing files for actual disk configuration..."
##SHOW_DISK_EDITS##
  for file in /etc/fstab /etc/systemconfig/systemconfig.conf /boot/grub/menu.lst /etc/lilo.conf /etc/grub.conf /boot/grub/device.map; do
    [ -f /sysroot/$file ] || continue
    echo " $file"
    cp /sysroot/$file /sysroot/$file.image
##EDIT_DISK_NAMES##
  done
  echo
  beep
}
#
# END disk edits
################################################################################

#export PATH=/usr/local/sbin:/usr/local/bin:$PATH
#logmsg "Detecting systemconfigurator:"
#logmsg "---"
#chroot /sysroot/ systemconfigurator --version || \
#    logmsg "WARNING: systemconfigurator was not found in the image $IMAGENAME"
#logmsg "---"

##SYSTEMCONFIGURATOR_POST##

#
################################################################################


################################################################################
#
#   Post Install Scripts
#
run_post_install_scripts
#
################################################################################

################################################################################
#
#   Save virtual console session in the imaged client
#
if [ ! -z $MONITOR_SERVER ]; then
    if [ "x$MONITOR_CONSOLE" = "xy" ]; then
        MONITOR_CONSOLE=yes
    fi
    if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
        [ ! -d /sysroot/root ] && mkdir -p /sysroot/root
	save_logs_to_sysroot # Saves /tmp/relevant install infos to /root/SIS_Install/
    fi
fi

#
################################################################################


################################################################################
#
#   Setup kexec if necessary
#
##SETUP_KEXEC##
#
################################################################################


################################################################################
#
#   Unmount filesystems
#
umount_os_filesystems_from_sysroot
##UMOUNT_FILESYSTEMS##
#
################################################################################


################################################################################
#
#   Tell the image server we are done
#
rsync $IMAGESERVER::scripts/imaging_complete_$IPADDR > /dev/null 2>&1
loginfo "Imaging completed"
#
################################################################################

if [ ! -z $MONITOR_SERVER ]; then
    # Report the 'imaged' state to the monitor server.
    send_monitor_msg "status=100:speed=0"
    if [ "x$MONITOR_CONSOLE" = "xy" ]; then
        MONITOR_CONSOLE=yes
    fi
    if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
        # Print some empty lines and sleep some seconds to give time to
        # the virtual console to get last messages.
        # XXX: this is a dirty solution, we should find a better way to
        # sync last messages... -AR-
        logmsg ""
        logmsg ""
        logmsg ""
        sleep 10
    fi
    # Report the post-install action.
##MONITOR_POSTINSTALL##
fi

# Explicitly kill sleep processes.
# This is needed to close the SSH tunnel on the image server when the
# SSH transport is used).
killall sleep >/dev/null 2>&1

# Announce completion (even for non beep-incessantly --post-install options)
beep 3

##POSTINSTALL##
